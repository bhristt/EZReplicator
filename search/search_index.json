{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home EZReplicator is a module that makes it easy to replicate objects, and send signals between the server and client. The purpose of the module is to provide reliable server-client replication without having to deal with the complexities of setting up an environment to replicate between server and client. With EZReplicator, you can create Subscriptions . A Subscription is a set of data that is created in the server, but automatically replicated to each client connected to the server. Each time a property inside a Subscription is changed, the property is automatically replicated to each client instantly after being changed. The benefits of using EZReplicator for replication purposes in your experience are: Easy to learn - EZReplicator is a module that is very easy to learn. It is meant to be beginner friendly, using mostly Getter and Setter functions Easily organize anything replication - EZReplicator makes it easy to organize your RemoteEvents and RemoteFunctions, because, with this module, there is no need to create any RemoteEvents or RemoteFunctions! Reliable, easy to fix errors - EZReplicator is meant to be a reliable module. It outputs custom error messages, making it easy to spot and fix errors Disclaimer : Although EZReplicator has been thoroughly tested, EZReplicator has not been used in any large scale Roblox projects before. Any errors or issues found in the module should be reported.","title":"Home"},{"location":"#home","text":"EZReplicator is a module that makes it easy to replicate objects, and send signals between the server and client. The purpose of the module is to provide reliable server-client replication without having to deal with the complexities of setting up an environment to replicate between server and client. With EZReplicator, you can create Subscriptions . A Subscription is a set of data that is created in the server, but automatically replicated to each client connected to the server. Each time a property inside a Subscription is changed, the property is automatically replicated to each client instantly after being changed. The benefits of using EZReplicator for replication purposes in your experience are: Easy to learn - EZReplicator is a module that is very easy to learn. It is meant to be beginner friendly, using mostly Getter and Setter functions Easily organize anything replication - EZReplicator makes it easy to organize your RemoteEvents and RemoteFunctions, because, with this module, there is no need to create any RemoteEvents or RemoteFunctions! Reliable, easy to fix errors - EZReplicator is meant to be a reliable module. It outputs custom error messages, making it easy to spot and fix errors Disclaimer : Although EZReplicator has been thoroughly tested, EZReplicator has not been used in any large scale Roblox projects before. Any errors or issues found in the module should be reported.","title":"Home"},{"location":"api/","text":"Notice Requiring the EZReplicator module from the Client will request the Server to send a table of all the Subscription objects made. If this request fails, it will retry the given amount of times specified in the Settings module inside the EZReplicator module. EZReplicator Properties EZReplicator.CLIENT_TABLE_FILTER_TYPES EZReplicator . CLIENT_TABLE_FILTER_TYPES [ Dictionary ] EZReplicator.CLIENT_TABLE_FILTER_TYPES is a dictionary containing the valid filter types of the Subscription client table. The client table filter type of a Subscription can be changed by changing Subscription.ClientTableFilterType . EZReplicator.CLIENT_TABLE_FILTER_TYPES is the dictionary: EZReplicator . CLIENT_TABLE_FILTER_TYPES = { WHITELIST = \"WHITELIST\" , BLACKLIST = \"BLACKLIST\" , } EZReplicator.SubscriptionAdded EZReplicator . SubscriptionAdded [ RBXScriptSignal ] ( newSubscription [ Subscription ]) This RBXScriptSignal is fired when a new Subscription is added to the EZReplicator Subscription store. EZReplicator.SubscriptionRemoved EZReplicator . SubscriptionRemoved [ RBXScriptSignal ] ( subscriptionRemoved [ Subscription ]) This RBXScriptSignal is fired when a Subscription has been removed from the EZReplicator Subscription store. EZReplicator Server Functions Warning EZReplicator server functions must be used in a server Script only ! Attempting to use EZReplicator server functions in the client will result in an error! EZReplicator:CreateSubscription() EZReplicator : CreateSubscription ( subscriptionName , propTable ) --> [Subscription] -- subscriptionName [string] -- Subscription name -- propTable [table]: -- Allows initialization of Subscription with custom properties -- { -- -- property names must be strings, property values can be anything -- [string]: [any] -- } -- OR -- propTable [nil] Creates a new Subscription object with the given name and initial property table. If the initial property table is nil , defaults to {} . This also fires the EZReplicator.SubscriptionAdded RBXScriptSignal. Warning If there is a Subscription in the EZReplicator Subscription store with the same name as the given Subscription name, then this function will throw an error. It is important that, when creating Subscriptions , to name each different Subscription a different name. EZReplicator:RemoveSubscription() EZReplicator : RemoveSubscription ( subscriptionName ) --> nil -- subscriptionName [string] -- The name of the Subscription to remove Removes the Subscription with the given name. This also fires the EZReplicator.SubscriptionRemoved RBXScriptSignal. Warning If a Subscription with the given name is NOT found, then the this function will throw an error. Make sure that your code keeps track of Subscription objects that are made and deleted. You can check if a Subscription with the given name exists by using EZReplicator:GetSubscription() EZReplicator:SendSignalToClient() EZReplicator : SendSignalToClient ( player , signalName , ... ) --> [boolean] -- player [Player] -- The player that the server is sending the signal to -- signalName [string] -- The name of the signal being sent to the client -- ... [any] -- The arguments being passed to the signal (supports multiple arguments) Sends a signal with the given name to the given client. Optional arguments may be passed to the signal. If the signal was successfully sent, the function returns true . If the signal sending process was not successul, the function returns false . EZReplicator:SendSignalToAllClientsExcept() EZReplicator : SendSignalToAllClientsExcept ( plrs , signalName , ... ) --> [table]: -- { -- -- A table which shows which signals were successful for which players -- [Player]: [boolean] -- } -- -- -- plrs [table]: -- { -- -- A regular numbered list of players -- [number]: [Player] -- } -- OR -- plrs [Player] -- A single player if a list of players is not required -- signalName [string] -- The name of the signal being sent to the client(s) -- ... [any] -- The arguments being passed to the signal (supports multiple arguments) Sends a signal with the given name to all clients except for the given players. Optional arguments may be passed to the signal. Returns a table with Player indices whos respective values describe whether the signal was successfully sent to the respective client or not. Notice This function sends a signal to all other players, so the success table that is returned should have indices with all players but the provided players. The success table can be used to send a signal to the unsuccessfully signaled clients. EZReplicator:SendSignalToAllClients() EZReplicator : SendSignalToAllClients ( signalName , ... ) --> nil -- signalName [string] -- The name of the signal being sent to the client -- ... [any] -- The arguments being passed to the signal (supports multiple arguments) Sends a signal with the given name to all clients connected to the server. Optional arguments may be passed to the signal. Does not return anything. Notice This function uses the default RemoteEvent:FireAllClients() function, not a custom fire all clients function. This function is prone to errors, so I may add a custom procedure in the future for success checking. EZReplicator:GetClientSignal() EZReplicator : GetClientSignal ( signalName ) --> [RBXScriptSignal] (player [Player], ... [any]) -- signalName [string] -- The name of the signal requested Gets an RBXScriptSignal for the client signal with the given name. When the client sends a signal to the server with the given name, the signal received by this function will fire. EZReplicator:RequestDataFromClient() EZReplicator : RequestDataFromClient ( player , dataKey , ... ) --> [boolean, any] -- player [Player] -- The client which the server is requesting data from -- dataKey [string] -- The dataKey of the data request -- ... [any] -- The arguments passed along with the request (supports multiple arguments) Requests data from the given dataKey from the given client. Optional arguments may be passed to the request. Returns whether the request was successful as the first return argument, and the data as the second return argument. Notice The success and data return arguments are received from the pcall function. This being said, it is important to note that if the success return argument of the function is false, then the data return argument of the function will be an error message string, not nil . EZReplicator:SetServerRequestHandler() EZReplicator : SetServerRequestHandler ( dataKey , func ) --> nil -- dataKey [string] -- The dataKey of the server request -- func [function] (player [Player], ... [any]) --> [any] -- A function in the server that returns the data requested from the client Sets the server request handler for the given dataKey to the given handler function. The given handler function must return the value that is being requested by the client. Notice This function does not check for overwriting dataKeys. If a dataKey has already been defined, and this function gets called again using the same dataKey, the previous dataKey handler gets overwritten with the new dataKey handler. EZReplicator Client Functions Warning EZReplicator client functions can be used in a LocalScript only ! Attempting to use EZReplicator client functions in the server will result in an error! EZReplicator:SendSignalToServer() EZReplicator : SendSignalToServer ( signalName , ... ) --> nil -- signalName [string] -- The name of the signal to send to the server -- ... [any] -- The arguments passed to the signal (supports multiple arguments) Sends a signal with the given name to the server. Optional arguments may be passed to the signal. Does not return anything. EZReplicator:GetServerSignal() EZReplicator : GetServerSignal ( signalName ) --> [RBXScriptSignal] (... [any]) -- signalName [string] -- The name of the signal requested Gets an RBXScriptSignal for the server signal with the given name. When the server sends a signal to the client with the given name, the signal received by this function will fire. EZReplicator:RequestDataFromServer() EZReplicator : RequestDataFromServer ( dataKey , ... ) --> [boolean, any] -- dataKey [string] -- ... [any] Requests data from the given dataKey from the server. Optional arguments may be passed to the request. Returns whether the request was successful as the first return argument, and the data as the second return argument. Notice The success and data return arguments are received from the pcall function. This being said, it is important to note that if the success return argument of the function is false, then the data return argument of the function will be an error message string, not nil . EZReplicator:SetClientRequestHandler() EZReplicator : SetClientRequestHandler ( dataKey , func ) --> nil -- dataKey [string] -- func [function] (... [any]) Sets the client request handler for the given dataKey to the given handler function. The given handler function must return the value that is being requested by the server. Notice This function does not check for overwriting dataKeys. If a dataKey has already been defined, and this function gets called again using the same dataKey, the previous dataKey handler gets overwritten with the new dataKey handler. EZReplicator Universal Functions EZReplicator:Init() EZReplicator : Init () --> nil Initializes the EZReplicator object. This is a function called once at the creation of the EZReplicator object. This function does nothing after it is called the first time. EZReplicator:WaitForSubscription() EZReplicator : WaitForSubscription ( subscriptionName ) --> [Subscription] OR nil -- subscriptionName [string] Waits for the Subscription with the given name. If the function yields for more than the time given in the Settings module, then the function returns nil. Warning If the function happens to yield for more than the yield time specified in the Settings module, the function will print a warning message to the console. EZReplicator:GetSubscription() EZReplicator : GetSubscription ( subscriptionName , yield ) --> [Subscription] or nil -- subscriptionName [string] -- yield [boolean] -- OR -- yield [nil] Gets the Subscription with the given name. Optional yield parameter for waiting for the Subscription instead (which does the same thing as EZReplicator:WaitForSubscription() ). If yield is not specified, defaults to false . Subscription Properties Subscription.Properties Subscription . Properties [ table ]: -- { -- -- a table with string indices and any values -- [string]: [any] -- } Contains the properties of the Subscription . Subscription.StoreTablePropertyAsPointer Subscription . StoreTablePropertyAsPointer [ boolean ] An option to store table value properties in the property table as pointers referencing the same table, or clones of the provided tables. If this is set to true, will store table property values as pointers instead of making clones of the given tables. Subscription.UpdateAllSubscriptionsOnPropChanged Subscription . UpdateAllSubscriptionsOnPropChanged [ boolean ] An option to update the Subscription for all clients connected to the server. If this is set to false, you must specify the clients that will be automatically updated when the Subscription is changed in the server. Subscription.ClientTableFilterType Subscription . ClientTableFilterType [ string ] \"WHITELIST\" , or \"BLACKLIST\" The filter type of the client table of the Subscription . You can set this by typing a string, or using the EZReplicator.CLIENT_TABLE_FILTER_TYPES dictionary. For example, Subscription . ClientTableFilterType = \"WHITELIST\" -- OR Subscription . ClientTableFilterType = EZReplicator . CLIENT_TABLE_FILTER_TYPES . WHITELIST Subscription.PropertyAdded Subscription . PropertyAdded [ RBXScriptSignal ] ( propIndex [ string ], propValue [ any ]) An RBXScriptSignal used for signaling that a new property has been added to the Subscription . Subscription.PropertyChanged Subscription . PropertyChanged [ RBXScriptSignal ] ( propIndex [ string ], propValue [ any ]) An RBXScriptSignal used for signaling that a property in the Subscription has been changed. Subscription.PropertyRemoved Subscription . PropertyRemoved [ RBXScriptSignal ] ( propIndex [ string ]) An RBXScriptSignal used for signaling that a property in the Subscription was removed. Subscription Server Functions Subscription:AddProperty() Subscription : AddProperty ( propIndex , propValue ) --> nil -- propIndex [string] -- propValue [any] Adds a property to the Subscription with the given index and the given value. Warning Attempting to add a property to the Subscription with an already existing index results in an error. It is important to keep track of property indices! Failure Do not attempt to add properties by adding indices to the Subscription.Properties table directly! This will result in an error. Subscription:SetProperty() Subscription : SetProperty ( propIndex , propValue ) --> nil -- propIndex [string] -- propValue [any] Sets the value of the property with the given index to the given value. Failure Attempting to change the value of a property by changing the Subscription.Properties table directly will result in unintended behavior! Subscription:RemoveProperty() Subscription : RemoveProperty ( propIndex ) --> nil -- propIndex [string] Removes the property with the given index from the Subscription . Warning If there is not a property with the given index in the Subscription , then an error will be thrown. It is important to keep track of property indices. Failure Attempting to remove a property from the Subscription by changing the Subscription.Properties table directly will result in unintended behavior! Subscription:AddPlayerToClientTbl() Subscription : AddPlayerToClientTbl ( player ) --> nil -- player [Player] Adds a player to the Subscription client table. If the client table already contains the player, then this function does nothing. Subscription:GetClientTbl() Subscription : GetClientTbl () --> [table]: -- { -- [number]: [Player] -- } Gets a copy of the client table. Subscription:GetFilteredClientTbl() Subscription : GetFilteredClientTbl () --> [table]: -- { -- [number]: [Player] -- } Gets a copy of the filtered client table. Filtered refers to the Subscription.ClientTableFilterType property. Subscription:IterateThroughFilteredCTbl() Subscription : IterateThroughFilteredCTbl ( func ) --> nil -- func [function] (plr [Player]) --> nil Iterates through the filtered client table and calls the given function, passing the player in the iteration as the argument. Subscription:RemovePlayerFromClientTbl() Subscription : RemovePlayerFromClientTbl ( player ) --> nil -- player [Player] Removes the given player from the Subscription client table. If the given player is already not in the client table, does nothing. Subscription Client Functions Subscription:UpdateSubscription() Subscription : UpdateSubscription ( propTable ) --> nil -- propTable [table]: -- { -- [string]: [any] -- } Sets the property table of the Subscription to the give property table. As it does this, it fires the changed signals for each property that is changed. Notice This function should not be used at all if the Subscription is being replicated on the client. It is intended to only be used by the EZReplicator module for updating Subscription properties! Subscription Universal Functions Subscription:Init() Subscription : Init () --> nil Initializes the Subscription object. This is a function called once at the creation of the Subscription object. This function does nothing after it is called the first time. Subscription:GetProperty() Subscription : GetProperty ( propIndex ) --> [any] -- propIndex [string] Gets the property with the given index from the Subscription . Warning If the given property index does not exist in the Subscription , then this function will throw an error. Subscription:GetPropertyChangedSignal() Subscription : GetPropertyChangedSignal ( propIndex ) --> [RBXScriptSignal] -- propIndex [string] Gets an RBXScriptSignal for the property in the Subscription with the given index. Notice This function will not throw an error if a signal for a non-existing property is requested.","title":"API"},{"location":"api/#ezreplicator-properties","text":"","title":"EZReplicator Properties"},{"location":"api/#ezreplicatorclient_table_filter_types","text":"EZReplicator . CLIENT_TABLE_FILTER_TYPES [ Dictionary ] EZReplicator.CLIENT_TABLE_FILTER_TYPES is a dictionary containing the valid filter types of the Subscription client table. The client table filter type of a Subscription can be changed by changing Subscription.ClientTableFilterType . EZReplicator.CLIENT_TABLE_FILTER_TYPES is the dictionary: EZReplicator . CLIENT_TABLE_FILTER_TYPES = { WHITELIST = \"WHITELIST\" , BLACKLIST = \"BLACKLIST\" , }","title":"EZReplicator.CLIENT_TABLE_FILTER_TYPES"},{"location":"api/#ezreplicatorsubscriptionadded","text":"EZReplicator . SubscriptionAdded [ RBXScriptSignal ] ( newSubscription [ Subscription ]) This RBXScriptSignal is fired when a new Subscription is added to the EZReplicator Subscription store.","title":"EZReplicator.SubscriptionAdded"},{"location":"api/#ezreplicatorsubscriptionremoved","text":"EZReplicator . SubscriptionRemoved [ RBXScriptSignal ] ( subscriptionRemoved [ Subscription ]) This RBXScriptSignal is fired when a Subscription has been removed from the EZReplicator Subscription store.","title":"EZReplicator.SubscriptionRemoved"},{"location":"api/#ezreplicator-server-functions","text":"Warning EZReplicator server functions must be used in a server Script only ! Attempting to use EZReplicator server functions in the client will result in an error!","title":"EZReplicator Server Functions"},{"location":"api/#ezreplicatorcreatesubscription","text":"EZReplicator : CreateSubscription ( subscriptionName , propTable ) --> [Subscription] -- subscriptionName [string] -- Subscription name -- propTable [table]: -- Allows initialization of Subscription with custom properties -- { -- -- property names must be strings, property values can be anything -- [string]: [any] -- } -- OR -- propTable [nil] Creates a new Subscription object with the given name and initial property table. If the initial property table is nil , defaults to {} . This also fires the EZReplicator.SubscriptionAdded RBXScriptSignal. Warning If there is a Subscription in the EZReplicator Subscription store with the same name as the given Subscription name, then this function will throw an error. It is important that, when creating Subscriptions , to name each different Subscription a different name.","title":"EZReplicator:CreateSubscription()"},{"location":"api/#ezreplicatorremovesubscription","text":"EZReplicator : RemoveSubscription ( subscriptionName ) --> nil -- subscriptionName [string] -- The name of the Subscription to remove Removes the Subscription with the given name. This also fires the EZReplicator.SubscriptionRemoved RBXScriptSignal. Warning If a Subscription with the given name is NOT found, then the this function will throw an error. Make sure that your code keeps track of Subscription objects that are made and deleted. You can check if a Subscription with the given name exists by using EZReplicator:GetSubscription()","title":"EZReplicator:RemoveSubscription()"},{"location":"api/#ezreplicatorsendsignaltoclient","text":"EZReplicator : SendSignalToClient ( player , signalName , ... ) --> [boolean] -- player [Player] -- The player that the server is sending the signal to -- signalName [string] -- The name of the signal being sent to the client -- ... [any] -- The arguments being passed to the signal (supports multiple arguments) Sends a signal with the given name to the given client. Optional arguments may be passed to the signal. If the signal was successfully sent, the function returns true . If the signal sending process was not successul, the function returns false .","title":"EZReplicator:SendSignalToClient()"},{"location":"api/#ezreplicatorsendsignaltoallclientsexcept","text":"EZReplicator : SendSignalToAllClientsExcept ( plrs , signalName , ... ) --> [table]: -- { -- -- A table which shows which signals were successful for which players -- [Player]: [boolean] -- } -- -- -- plrs [table]: -- { -- -- A regular numbered list of players -- [number]: [Player] -- } -- OR -- plrs [Player] -- A single player if a list of players is not required -- signalName [string] -- The name of the signal being sent to the client(s) -- ... [any] -- The arguments being passed to the signal (supports multiple arguments) Sends a signal with the given name to all clients except for the given players. Optional arguments may be passed to the signal. Returns a table with Player indices whos respective values describe whether the signal was successfully sent to the respective client or not. Notice This function sends a signal to all other players, so the success table that is returned should have indices with all players but the provided players. The success table can be used to send a signal to the unsuccessfully signaled clients.","title":"EZReplicator:SendSignalToAllClientsExcept()"},{"location":"api/#ezreplicatorsendsignaltoallclients","text":"EZReplicator : SendSignalToAllClients ( signalName , ... ) --> nil -- signalName [string] -- The name of the signal being sent to the client -- ... [any] -- The arguments being passed to the signal (supports multiple arguments) Sends a signal with the given name to all clients connected to the server. Optional arguments may be passed to the signal. Does not return anything. Notice This function uses the default RemoteEvent:FireAllClients() function, not a custom fire all clients function. This function is prone to errors, so I may add a custom procedure in the future for success checking.","title":"EZReplicator:SendSignalToAllClients()"},{"location":"api/#ezreplicatorgetclientsignal","text":"EZReplicator : GetClientSignal ( signalName ) --> [RBXScriptSignal] (player [Player], ... [any]) -- signalName [string] -- The name of the signal requested Gets an RBXScriptSignal for the client signal with the given name. When the client sends a signal to the server with the given name, the signal received by this function will fire.","title":"EZReplicator:GetClientSignal()"},{"location":"api/#ezreplicatorrequestdatafromclient","text":"EZReplicator : RequestDataFromClient ( player , dataKey , ... ) --> [boolean, any] -- player [Player] -- The client which the server is requesting data from -- dataKey [string] -- The dataKey of the data request -- ... [any] -- The arguments passed along with the request (supports multiple arguments) Requests data from the given dataKey from the given client. Optional arguments may be passed to the request. Returns whether the request was successful as the first return argument, and the data as the second return argument. Notice The success and data return arguments are received from the pcall function. This being said, it is important to note that if the success return argument of the function is false, then the data return argument of the function will be an error message string, not nil .","title":"EZReplicator:RequestDataFromClient()"},{"location":"api/#ezreplicatorsetserverrequesthandler","text":"EZReplicator : SetServerRequestHandler ( dataKey , func ) --> nil -- dataKey [string] -- The dataKey of the server request -- func [function] (player [Player], ... [any]) --> [any] -- A function in the server that returns the data requested from the client Sets the server request handler for the given dataKey to the given handler function. The given handler function must return the value that is being requested by the client. Notice This function does not check for overwriting dataKeys. If a dataKey has already been defined, and this function gets called again using the same dataKey, the previous dataKey handler gets overwritten with the new dataKey handler.","title":"EZReplicator:SetServerRequestHandler()"},{"location":"api/#ezreplicator-client-functions","text":"Warning EZReplicator client functions can be used in a LocalScript only ! Attempting to use EZReplicator client functions in the server will result in an error!","title":"EZReplicator Client Functions"},{"location":"api/#ezreplicatorsendsignaltoserver","text":"EZReplicator : SendSignalToServer ( signalName , ... ) --> nil -- signalName [string] -- The name of the signal to send to the server -- ... [any] -- The arguments passed to the signal (supports multiple arguments) Sends a signal with the given name to the server. Optional arguments may be passed to the signal. Does not return anything.","title":"EZReplicator:SendSignalToServer()"},{"location":"api/#ezreplicatorgetserversignal","text":"EZReplicator : GetServerSignal ( signalName ) --> [RBXScriptSignal] (... [any]) -- signalName [string] -- The name of the signal requested Gets an RBXScriptSignal for the server signal with the given name. When the server sends a signal to the client with the given name, the signal received by this function will fire.","title":"EZReplicator:GetServerSignal()"},{"location":"api/#ezreplicatorrequestdatafromserver","text":"EZReplicator : RequestDataFromServer ( dataKey , ... ) --> [boolean, any] -- dataKey [string] -- ... [any] Requests data from the given dataKey from the server. Optional arguments may be passed to the request. Returns whether the request was successful as the first return argument, and the data as the second return argument. Notice The success and data return arguments are received from the pcall function. This being said, it is important to note that if the success return argument of the function is false, then the data return argument of the function will be an error message string, not nil .","title":"EZReplicator:RequestDataFromServer()"},{"location":"api/#ezreplicatorsetclientrequesthandler","text":"EZReplicator : SetClientRequestHandler ( dataKey , func ) --> nil -- dataKey [string] -- func [function] (... [any]) Sets the client request handler for the given dataKey to the given handler function. The given handler function must return the value that is being requested by the server. Notice This function does not check for overwriting dataKeys. If a dataKey has already been defined, and this function gets called again using the same dataKey, the previous dataKey handler gets overwritten with the new dataKey handler.","title":"EZReplicator:SetClientRequestHandler()"},{"location":"api/#ezreplicator-universal-functions","text":"","title":"EZReplicator Universal Functions"},{"location":"api/#ezreplicatorinit","text":"EZReplicator : Init () --> nil Initializes the EZReplicator object. This is a function called once at the creation of the EZReplicator object. This function does nothing after it is called the first time.","title":"EZReplicator:Init()"},{"location":"api/#ezreplicatorwaitforsubscription","text":"EZReplicator : WaitForSubscription ( subscriptionName ) --> [Subscription] OR nil -- subscriptionName [string] Waits for the Subscription with the given name. If the function yields for more than the time given in the Settings module, then the function returns nil. Warning If the function happens to yield for more than the yield time specified in the Settings module, the function will print a warning message to the console.","title":"EZReplicator:WaitForSubscription()"},{"location":"api/#ezreplicatorgetsubscription","text":"EZReplicator : GetSubscription ( subscriptionName , yield ) --> [Subscription] or nil -- subscriptionName [string] -- yield [boolean] -- OR -- yield [nil] Gets the Subscription with the given name. Optional yield parameter for waiting for the Subscription instead (which does the same thing as EZReplicator:WaitForSubscription() ). If yield is not specified, defaults to false .","title":"EZReplicator:GetSubscription()"},{"location":"api/#subscription-properties","text":"","title":"Subscription Properties"},{"location":"api/#subscriptionproperties","text":"Subscription . Properties [ table ]: -- { -- -- a table with string indices and any values -- [string]: [any] -- } Contains the properties of the Subscription .","title":"Subscription.Properties"},{"location":"api/#subscriptionstoretablepropertyaspointer","text":"Subscription . StoreTablePropertyAsPointer [ boolean ] An option to store table value properties in the property table as pointers referencing the same table, or clones of the provided tables. If this is set to true, will store table property values as pointers instead of making clones of the given tables.","title":"Subscription.StoreTablePropertyAsPointer"},{"location":"api/#subscriptionupdateallsubscriptionsonpropchanged","text":"Subscription . UpdateAllSubscriptionsOnPropChanged [ boolean ] An option to update the Subscription for all clients connected to the server. If this is set to false, you must specify the clients that will be automatically updated when the Subscription is changed in the server.","title":"Subscription.UpdateAllSubscriptionsOnPropChanged"},{"location":"api/#subscriptionclienttablefiltertype","text":"Subscription . ClientTableFilterType [ string ] \"WHITELIST\" , or \"BLACKLIST\" The filter type of the client table of the Subscription . You can set this by typing a string, or using the EZReplicator.CLIENT_TABLE_FILTER_TYPES dictionary. For example, Subscription . ClientTableFilterType = \"WHITELIST\" -- OR Subscription . ClientTableFilterType = EZReplicator . CLIENT_TABLE_FILTER_TYPES . WHITELIST","title":"Subscription.ClientTableFilterType"},{"location":"api/#subscriptionpropertyadded","text":"Subscription . PropertyAdded [ RBXScriptSignal ] ( propIndex [ string ], propValue [ any ]) An RBXScriptSignal used for signaling that a new property has been added to the Subscription .","title":"Subscription.PropertyAdded"},{"location":"api/#subscriptionpropertychanged","text":"Subscription . PropertyChanged [ RBXScriptSignal ] ( propIndex [ string ], propValue [ any ]) An RBXScriptSignal used for signaling that a property in the Subscription has been changed.","title":"Subscription.PropertyChanged"},{"location":"api/#subscriptionpropertyremoved","text":"Subscription . PropertyRemoved [ RBXScriptSignal ] ( propIndex [ string ]) An RBXScriptSignal used for signaling that a property in the Subscription was removed.","title":"Subscription.PropertyRemoved"},{"location":"api/#subscription-server-functions","text":"","title":"Subscription Server Functions"},{"location":"api/#subscriptionaddproperty","text":"Subscription : AddProperty ( propIndex , propValue ) --> nil -- propIndex [string] -- propValue [any] Adds a property to the Subscription with the given index and the given value. Warning Attempting to add a property to the Subscription with an already existing index results in an error. It is important to keep track of property indices! Failure Do not attempt to add properties by adding indices to the Subscription.Properties table directly! This will result in an error.","title":"Subscription:AddProperty()"},{"location":"api/#subscriptionsetproperty","text":"Subscription : SetProperty ( propIndex , propValue ) --> nil -- propIndex [string] -- propValue [any] Sets the value of the property with the given index to the given value. Failure Attempting to change the value of a property by changing the Subscription.Properties table directly will result in unintended behavior!","title":"Subscription:SetProperty()"},{"location":"api/#subscriptionremoveproperty","text":"Subscription : RemoveProperty ( propIndex ) --> nil -- propIndex [string] Removes the property with the given index from the Subscription . Warning If there is not a property with the given index in the Subscription , then an error will be thrown. It is important to keep track of property indices. Failure Attempting to remove a property from the Subscription by changing the Subscription.Properties table directly will result in unintended behavior!","title":"Subscription:RemoveProperty()"},{"location":"api/#subscriptionaddplayertoclienttbl","text":"Subscription : AddPlayerToClientTbl ( player ) --> nil -- player [Player] Adds a player to the Subscription client table. If the client table already contains the player, then this function does nothing.","title":"Subscription:AddPlayerToClientTbl()"},{"location":"api/#subscriptiongetclienttbl","text":"Subscription : GetClientTbl () --> [table]: -- { -- [number]: [Player] -- } Gets a copy of the client table.","title":"Subscription:GetClientTbl()"},{"location":"api/#subscriptiongetfilteredclienttbl","text":"Subscription : GetFilteredClientTbl () --> [table]: -- { -- [number]: [Player] -- } Gets a copy of the filtered client table. Filtered refers to the Subscription.ClientTableFilterType property.","title":"Subscription:GetFilteredClientTbl()"},{"location":"api/#subscriptioniteratethroughfilteredctbl","text":"Subscription : IterateThroughFilteredCTbl ( func ) --> nil -- func [function] (plr [Player]) --> nil Iterates through the filtered client table and calls the given function, passing the player in the iteration as the argument.","title":"Subscription:IterateThroughFilteredCTbl()"},{"location":"api/#subscriptionremoveplayerfromclienttbl","text":"Subscription : RemovePlayerFromClientTbl ( player ) --> nil -- player [Player] Removes the given player from the Subscription client table. If the given player is already not in the client table, does nothing.","title":"Subscription:RemovePlayerFromClientTbl()"},{"location":"api/#subscription-client-functions","text":"","title":"Subscription Client Functions"},{"location":"api/#subscriptionupdatesubscription","text":"Subscription : UpdateSubscription ( propTable ) --> nil -- propTable [table]: -- { -- [string]: [any] -- } Sets the property table of the Subscription to the give property table. As it does this, it fires the changed signals for each property that is changed. Notice This function should not be used at all if the Subscription is being replicated on the client. It is intended to only be used by the EZReplicator module for updating Subscription properties!","title":"Subscription:UpdateSubscription()"},{"location":"api/#subscription-universal-functions","text":"","title":"Subscription Universal Functions"},{"location":"api/#subscriptioninit","text":"Subscription : Init () --> nil Initializes the Subscription object. This is a function called once at the creation of the Subscription object. This function does nothing after it is called the first time.","title":"Subscription:Init()"},{"location":"api/#subscriptiongetproperty","text":"Subscription : GetProperty ( propIndex ) --> [any] -- propIndex [string] Gets the property with the given index from the Subscription . Warning If the given property index does not exist in the Subscription , then this function will throw an error.","title":"Subscription:GetProperty()"},{"location":"api/#subscriptiongetpropertychangedsignal","text":"Subscription : GetPropertyChangedSignal ( propIndex ) --> [RBXScriptSignal] -- propIndex [string] Gets an RBXScriptSignal for the property in the Subscription with the given index. Notice This function will not throw an error if a signal for a non-existing property is requested.","title":"Subscription:GetPropertyChangedSignal()"},{"location":"updates/","text":"Initial Release [March 21, 2022] Initial release focuses on providing easy to setup replication between client and server with the use of one module. EZReplicator was finalized on this day. Added subscription objects that automatically update on specified clients when changed on the server. Added signals and signal handlers Added requests and request handlers Added RBXScriptSignals to EZReplicator for listening to general EZReplicator events Added RBXScriptSignals to Subscriptions for listening to Subscription related events","title":"Updates"},{"location":"updates/#initial-release-march-21-2022","text":"Initial release focuses on providing easy to setup replication between client and server with the use of one module. EZReplicator was finalized on this day. Added subscription objects that automatically update on specified clients when changed on the server. Added signals and signal handlers Added requests and request handlers Added RBXScriptSignals to EZReplicator for listening to general EZReplicator events Added RBXScriptSignals to Subscriptions for listening to Subscription related events","title":"Initial Release [March 21, 2022]"},{"location":"tutorial/advanced_subscriptions/","text":"","title":"Advanced Subscription Usage"},{"location":"tutorial/getting_started/","text":"EZReplicator is a ModuleScript that can be found in the Roblox library or on GitHub. The EZReplicator module should be a descendant of ReplicatedStorage , but does not have to be parented to ReplicatedStorage . There are a few options for how to get EZReplicator: Option 1 (recommended) Get the libary model via Roblox here Move the EZReplicator module into ReplicatedStorage , or move it into a folder inside ReplicatedStorage (module must be a descendant of ReplicatedStorage ) Option 2 Follow the instructions in the github repository for EZReplicator EZReplicator repository","title":"Getting Started"},{"location":"tutorial/getting_started/#option-1-recommended","text":"Get the libary model via Roblox here Move the EZReplicator module into ReplicatedStorage , or move it into a folder inside ReplicatedStorage (module must be a descendant of ReplicatedStorage )","title":"Option 1 (recommended)"},{"location":"tutorial/getting_started/#option-2","text":"Follow the instructions in the github repository for EZReplicator EZReplicator repository","title":"Option 2"},{"location":"tutorial/requests/","text":"EZReplicator also comes with support for requesting data from the server and client. Requesting data is more time consuming than sending signals, but it is useful for when the server needs a value from a client, or when the client needs a value from the server. In general, it is recommended to use EZReplicator to request data from the server ONLY . Anything in the client can be changed by external sources, so data from the client is not generally trusted. Requesting Data from the Server Requesting for data from the server in a LocalScript is done by using EZReplicator:RequestDataFromServer() . This function sends a signal to the server, checks to see if the server has a handler for the given request, then returns the data requested. A handler for the request can be made in the server. In order for data to be requested, there must be a handler made for the request on the appropriate Script/LocalScript. For requesting data from the server, a handler must be made on the server. This can be done by using EZReplicator:SetServerRequestHandler() . To create a handler, in a Script, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// creates a handler for the \"MAIN_REQUEST\" request EZReplicator : SetServerRequestHandler ( \"MAIN_REQUEST\" , function ( player ) return \"This is what \" .. tostring ( player . DisplayName ) .. \"'s client requested!\" end ) The above handler will return a string to the client that requested the data from the \"MAIN_REQUEST\" request. For example, if a player named \"bhristt\" was requesting data from the \"MAIN_REQUEST\" request server handler, then the data returned would be the string \"This is what bhristt's client requested!\" Now the question is, \"how do we request data from the server?\" Let's make some example code. In the client, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// requests data from the server defined by the \"MAIN_REQUEST\" request handler local success , playerString = EZReplicator : RequestDataFromServer ( \"MAIN_REQUEST\" ) --// print the request result print ( playerString ) The code above will request data from the client defined by the \"MAIN_REQUEST\" server handler. Then, the received data will be printed to the console. The output should look something like: This is what bhristt's client requested! Requesting Data from the Client Requesting data from the client is a very similar process to requesting data from the server. The only difference when it comes to requesting data from the client is that the handler for the request must be made on the client side. We can do this by using EZReplicator:SetClientRequestHandler() . To create a handler for requesting data from the client, in a LocalScript, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// create a handler named \"GIVE_ME_A_NUMBER\" EZReplicator : SetClientRequestHandler ( \"GIVE_ME_A_NUMBER\" , function () return math.random ( 1 , 10 ) end ) The above code creates a request handler in the client named \"GIVE_ME_A_NUMBER\". When the server requests this data from the client, a random number between 1 and 10 should be returned. Similarly to how we requested data from the server, we can request data from the client using EZReplicator:RequestDataFromClient() . In a Script, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) local playerList = Players : GetPlayers () local randPlayer = playerList [ math.random ( 1 , # playerList )] --// request data from the client defined by the client handler named \"GIVE_ME_A_NUMBER\" local success , randomNumber = EZReplicator : RequestDataFromClient ( randPlayer , \"GIVE_ME_A_NUMBER\" ) print ( randomNumber ) The above code requests the data from a random client, then prints it to the console. The output of the code above should look something like: 4 Handling Unsuccessful Data Requests Because RemoteFunctions can sometimes fail when invoked, the RequestDataFrom functions return a \"success\" boolean. This boolean tells us whether the request was successful or not. If we request data and success is false, then we can handle this unsuccessful data request by trying to request the data again. Let's say we are trying to get data from a client. This request has a maximum of three retries, and after the third retry, the request is ignored. In a server Script, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) local playerList = Players : GetPlayers () local randPlayer = playerList [ math.random ( 1 , # playerList )] local MAX_REQUEST_RETRIES = 3 local success , result do local n = 0 while n < MAX_REQUEST_RETRIES do success , result = EZReplicator : RequestDataFromClient ( randPlayer , \"DATA_REQUEST\" ) if success then break end n += 1 end end --// check to see that the request was successful if success then print ( \"Request was successful!\" ) print ( \"The data received was: \" .. tostring ( result )) else print ( \"Request unsuccessul, ignoring request\" ) end","title":"Replicator Requests"},{"location":"tutorial/requests/#requesting-data-from-the-server","text":"Requesting for data from the server in a LocalScript is done by using EZReplicator:RequestDataFromServer() . This function sends a signal to the server, checks to see if the server has a handler for the given request, then returns the data requested. A handler for the request can be made in the server. In order for data to be requested, there must be a handler made for the request on the appropriate Script/LocalScript. For requesting data from the server, a handler must be made on the server. This can be done by using EZReplicator:SetServerRequestHandler() . To create a handler, in a Script, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// creates a handler for the \"MAIN_REQUEST\" request EZReplicator : SetServerRequestHandler ( \"MAIN_REQUEST\" , function ( player ) return \"This is what \" .. tostring ( player . DisplayName ) .. \"'s client requested!\" end ) The above handler will return a string to the client that requested the data from the \"MAIN_REQUEST\" request. For example, if a player named \"bhristt\" was requesting data from the \"MAIN_REQUEST\" request server handler, then the data returned would be the string \"This is what bhristt's client requested!\" Now the question is, \"how do we request data from the server?\" Let's make some example code. In the client, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// requests data from the server defined by the \"MAIN_REQUEST\" request handler local success , playerString = EZReplicator : RequestDataFromServer ( \"MAIN_REQUEST\" ) --// print the request result print ( playerString ) The code above will request data from the client defined by the \"MAIN_REQUEST\" server handler. Then, the received data will be printed to the console. The output should look something like: This is what bhristt's client requested!","title":"Requesting Data from the Server"},{"location":"tutorial/requests/#requesting-data-from-the-client","text":"Requesting data from the client is a very similar process to requesting data from the server. The only difference when it comes to requesting data from the client is that the handler for the request must be made on the client side. We can do this by using EZReplicator:SetClientRequestHandler() . To create a handler for requesting data from the client, in a LocalScript, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// create a handler named \"GIVE_ME_A_NUMBER\" EZReplicator : SetClientRequestHandler ( \"GIVE_ME_A_NUMBER\" , function () return math.random ( 1 , 10 ) end ) The above code creates a request handler in the client named \"GIVE_ME_A_NUMBER\". When the server requests this data from the client, a random number between 1 and 10 should be returned. Similarly to how we requested data from the server, we can request data from the client using EZReplicator:RequestDataFromClient() . In a Script, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) local playerList = Players : GetPlayers () local randPlayer = playerList [ math.random ( 1 , # playerList )] --// request data from the client defined by the client handler named \"GIVE_ME_A_NUMBER\" local success , randomNumber = EZReplicator : RequestDataFromClient ( randPlayer , \"GIVE_ME_A_NUMBER\" ) print ( randomNumber ) The above code requests the data from a random client, then prints it to the console. The output of the code above should look something like: 4","title":"Requesting Data from the Client"},{"location":"tutorial/requests/#handling-unsuccessful-data-requests","text":"Because RemoteFunctions can sometimes fail when invoked, the RequestDataFrom functions return a \"success\" boolean. This boolean tells us whether the request was successful or not. If we request data and success is false, then we can handle this unsuccessful data request by trying to request the data again. Let's say we are trying to get data from a client. This request has a maximum of three retries, and after the third retry, the request is ignored. In a server Script, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) local playerList = Players : GetPlayers () local randPlayer = playerList [ math.random ( 1 , # playerList )] local MAX_REQUEST_RETRIES = 3 local success , result do local n = 0 while n < MAX_REQUEST_RETRIES do success , result = EZReplicator : RequestDataFromClient ( randPlayer , \"DATA_REQUEST\" ) if success then break end n += 1 end end --// check to see that the request was successful if success then print ( \"Request was successful!\" ) print ( \"The data received was: \" .. tostring ( result )) else print ( \"Request unsuccessul, ignoring request\" ) end","title":"Handling Unsuccessful Data Requests"},{"location":"tutorial/signals/","text":"EZReplicator comes with functions to send signals from both the server and the client. Sending signals is simple, and can be done by adding only a few lines of code. Sending Signals from the Client Let's consider a scenario where we want to send a signal to the server every time a player clicks a button. This can be done by using EZReplicator:SendSignalToServer() to send a signal every time the button is clicked. We can set this signal up in the client like so: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) local button = script . Parent : FindFirstChild ( \"TextButton\" ) button . MouseButton1Down : Connect ( function () --// send a signal to the server that the player clicked the button EZReplicator : SendSignalToServer ( \"PlayerClickedButton\" ) end ) Listening for Client Signals in the Server Now that the client sends a signal every time the button is clicked, how do we listen for that signal in the server? This can be done by using EZReplicator:GetClientSignal() to create a connection to the signal. For example, in the server, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// create a connection to the signal EZReplicator : GetClientSignal ( \"PlayerClickedButton\" ): Connect ( function ( player ) print ( tostring ( player . DisplayName ) .. \" clicked a button!\" ) end ) The code above will create a connection to the Client Signal named \"PlayerClickedButton\". Then, when it's fired, will print the player's name followed by the text \" clicked a button!\". If a player named \"Player1\" clicks the button three times, then the output will look like Player1 clicked a button! Player1 clicked a button! Player1 clicked a button! Sending Signals from the Server For sending signals from the server to the client, there are three functions for doing so. The first function is EZReplicator:SendSignalToClient() . This function sends a signal to the provided client ONLY . It is useful when it comes to sending signals to specific players. This being said, let's consider a scenario where a signal must be sent to 1 random player to tell them a secret message. In the server, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) local plrs = Players : GetPlayers () local randPlr = plrs [ math.random ( 1 , # plrs )] --// sends a signal to a random player with the signal name \"SECRET_MESSAGE\" --// the first argument of the signal is the message \"This is a secret message!\" EZReplicator : SendSignalToClient ( randPlr , \"SECRET_MESSAGE\" , \"This is a secret message!\" ) Let's consider another scenario where a signal must be sent to all players at the same time. In this case, we can use the function EZReplicator:SendSignalToAllClients() . This function sends a signal to all the clients connected to the server. In the server, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// sends a signal to all players with the signal name \"EXPOSED_MESSAGE\" --// the first argument of the signal is the message \"This is an exposed message!\" EZReplicator : SendSignalToAllClients ( \"EXPOSED_MESSAGE\" , \"This is an exposed message!\" ) For the final scenario, let's consider a case where we want to send a signal to all players except some players. In this case, we can use the function EZReplicator:SendSignalToAllClientsExcept() . This function sends a signal to all players connected to the server except for the provided player(s). In the server, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// create an ignore list of players --// for this example, let's say this game always has --// more than 4 people playing local plrs = Players : GetPlayers () local plrsIgnore = {} for i = 1 , 4 do table.insert ( plrsIgnore , table.remove ( plrs , math.random ( 1 , # plrs ))) end --// sends a signal to all players except the ones --// that were placed in the ignore list EZReplicator : SendSignalToAllClientsExcept ( plrsIgnore , \"HIDDEN_MESSAGE\" , \"This is a message that is hidden to some players!\" ) Listening for Server Signals in the Client Similar to how we listen for Signals in the Server from the Client, we can listen to Signals in the Client from the Server. This is done using the function EZReplicator:GetServerSignal() to create a connection to the signal. For this example, let's say we were continuing case 2 of sending signals to the client from the server. In the client, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// create a connection to the signal EZReplicator : GetServerSignal ( \"EXPOSED_MESSAGE\" ): Connect ( function ( exposedMessage ) print ( exposedMessage ) end ) The code above will create a connection to the Server Signal named \"EXPOSED_MESSAGE\". It also has a parameter called \"exposedMessage\", which contains the exposed message that was sent to the client from the server. The exposed message is then output to the console. The output would look something like This is an exposed message!","title":"Replicator Signals"},{"location":"tutorial/signals/#sending-signals-from-the-client","text":"Let's consider a scenario where we want to send a signal to the server every time a player clicks a button. This can be done by using EZReplicator:SendSignalToServer() to send a signal every time the button is clicked. We can set this signal up in the client like so: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) local button = script . Parent : FindFirstChild ( \"TextButton\" ) button . MouseButton1Down : Connect ( function () --// send a signal to the server that the player clicked the button EZReplicator : SendSignalToServer ( \"PlayerClickedButton\" ) end )","title":"Sending Signals from the Client"},{"location":"tutorial/signals/#listening-for-client-signals-in-the-server","text":"Now that the client sends a signal every time the button is clicked, how do we listen for that signal in the server? This can be done by using EZReplicator:GetClientSignal() to create a connection to the signal. For example, in the server, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// create a connection to the signal EZReplicator : GetClientSignal ( \"PlayerClickedButton\" ): Connect ( function ( player ) print ( tostring ( player . DisplayName ) .. \" clicked a button!\" ) end ) The code above will create a connection to the Client Signal named \"PlayerClickedButton\". Then, when it's fired, will print the player's name followed by the text \" clicked a button!\". If a player named \"Player1\" clicks the button three times, then the output will look like Player1 clicked a button! Player1 clicked a button! Player1 clicked a button!","title":"Listening for Client Signals in the Server"},{"location":"tutorial/signals/#sending-signals-from-the-server","text":"For sending signals from the server to the client, there are three functions for doing so. The first function is EZReplicator:SendSignalToClient() . This function sends a signal to the provided client ONLY . It is useful when it comes to sending signals to specific players. This being said, let's consider a scenario where a signal must be sent to 1 random player to tell them a secret message. In the server, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) local plrs = Players : GetPlayers () local randPlr = plrs [ math.random ( 1 , # plrs )] --// sends a signal to a random player with the signal name \"SECRET_MESSAGE\" --// the first argument of the signal is the message \"This is a secret message!\" EZReplicator : SendSignalToClient ( randPlr , \"SECRET_MESSAGE\" , \"This is a secret message!\" ) Let's consider another scenario where a signal must be sent to all players at the same time. In this case, we can use the function EZReplicator:SendSignalToAllClients() . This function sends a signal to all the clients connected to the server. In the server, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// sends a signal to all players with the signal name \"EXPOSED_MESSAGE\" --// the first argument of the signal is the message \"This is an exposed message!\" EZReplicator : SendSignalToAllClients ( \"EXPOSED_MESSAGE\" , \"This is an exposed message!\" ) For the final scenario, let's consider a case where we want to send a signal to all players except some players. In this case, we can use the function EZReplicator:SendSignalToAllClientsExcept() . This function sends a signal to all players connected to the server except for the provided player(s). In the server, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// create an ignore list of players --// for this example, let's say this game always has --// more than 4 people playing local plrs = Players : GetPlayers () local plrsIgnore = {} for i = 1 , 4 do table.insert ( plrsIgnore , table.remove ( plrs , math.random ( 1 , # plrs ))) end --// sends a signal to all players except the ones --// that were placed in the ignore list EZReplicator : SendSignalToAllClientsExcept ( plrsIgnore , \"HIDDEN_MESSAGE\" , \"This is a message that is hidden to some players!\" )","title":"Sending Signals from the Server"},{"location":"tutorial/signals/#listening-for-server-signals-in-the-client","text":"Similar to how we listen for Signals in the Server from the Client, we can listen to Signals in the Client from the Server. This is done using the function EZReplicator:GetServerSignal() to create a connection to the signal. For this example, let's say we were continuing case 2 of sending signals to the client from the server. In the client, local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// create a connection to the signal EZReplicator : GetServerSignal ( \"EXPOSED_MESSAGE\" ): Connect ( function ( exposedMessage ) print ( exposedMessage ) end ) The code above will create a connection to the Server Signal named \"EXPOSED_MESSAGE\". It also has a parameter called \"exposedMessage\", which contains the exposed message that was sent to the client from the server. The exposed message is then output to the console. The output would look something like This is an exposed message!","title":"Listening for Server Signals in the Client"},{"location":"tutorial/subscriptions/","text":"Basic usage of this module is very simple. A replication environment can be set up by using a Script parented to ServerScriptService , and a LocalScript that is a descendant of a Player object. Placing a LocalScript in ReplicatedFirst will also suffice. Server sided code In the Script placed in ServerScriptService , the following code will create a Subscription called \"MAIN\". --// assuming EZReplicator is placed in ReplicatedStorage, --// services local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) --// EZReplicator module local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// create a new subscription \"MAIN\" with initial properties --// this subscription contains the properties Foo and Hotel local MAIN_SUBSCRIPTION = EZReplicator : CreateSubscription ( \"MAIN\" , { Foo = \"Bar\" , Hotel = \"Trivago\" , }) Client sided code In the LocalScript, the following code will wait for the Subscription that was made in the server, and print out its properties. --// assuming EZReplicator is placed in ReplicatedStorage, --// services local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) --// EZReplicator module local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// wait for the \"MAIN\" subscription local MAIN_SUBSCRIPTION = EZReplicator : WaitForSubscription ( \"MAIN\" ) --// read out the properties of the \"MAIN\" subscription local mainSubscriptionProperties = MAIN_SUBSCRIPTION . Properties : GetProperties () for i , v in pairs ( mainSubscriptionProperties ) do print ( tostring ( i ) .. \": \" .. tostring ( v )) end If we were to play test in game with the Script and LocalScript having this code, the output would look something like Foo: Bar Hotel: Trivago Adding and Removing Subscription properties Let's consider a scenario where a Subscription has already been initialized. How do we add properties to the Subscription , and what are the limitations when it comes to adding properties? Adding properties to a Subscription is easy. To add a property to the Subscription , we can use the function Subscription:AddProperty() . In the server script, --// initialize the MAIN subscription local MAIN_SUBSCRIPTION = EZReplicator : CreateSubscription ( \"MAIN\" , { Foo = \"Bar\" , Hotel = \"Trivago\" , }) --// add more properties to the MAIN subscription --// adds the property named \"Goofy\" with the value \"Ahhhh\" MAIN_SUBSCRIPTION : AddProperty ( \"Goofy\" , \"Ahhhh\" ) --// adds the property named \"NinePlusTen\" with the value 21 MAIN_SUBSCRIPTION : AddProperty ( \"NinePlusTen\" , 21 ) The code above adds two properties to the \"MAIN\" Subscrpition . When a new property is added to a Subscription , an event is fired on the Client, but the value is automatically replicated to all clients. Trying to get the values of the new added properties on the client would not throw any errors. To remove properties, we can use the function Subscription:RemoveProperty() . In the server script, --// add more properties to the MAIN subscription --// adds the property named \"Goofy\" with the value \"Ahhhh\" MAIN_SUBSCRIPTION : AddProperty ( \"Goofy\" , \"Ahhhh\" ) --// adds the property named \"NinePlusTen\" with the value 21 MAIN_SUBSCRIPTION : AddProperty ( \"NinePlusTen\" , 21 ) --// what if we want to remove the NinePlusTen property? MAIN_SUBSCRIPTION : RemoveProperty ( \"NinePlusTen\" ) The above code removes the \"NinePlusTen\" property from the Subscription . Once again, this sends a signal to the Client, but also automatically replicates to each client. It is important to note that Subscription:AddProperty() and Subscription:RemoveProperty() are server only functions ! They cannot be used on the client. Changing Subscription properties Changing Subscription properties is also very easy. The subscription comes with the function Subscription:SetProperty() . Using this function, we can change the values of each property. For example, in the server script, --// initialize the MAIN subscription local MAIN_SUBSCRIPTION = EZReplicator : CreateSubscription ( \"MAIN\" , { Foo = \"Bar\" , Hotel = \"Trivago\" , }) --// change the value of Foo to Cat MAIN_SUBSCRIPTION : SetProperty ( \"Foo\" , \"Cat\" ) The Subscription:SetProperty() function is a server only function ! It cannot be used on the client.","title":"Basic Subscription Usage"},{"location":"tutorial/subscriptions/#server-sided-code","text":"In the Script placed in ServerScriptService , the following code will create a Subscription called \"MAIN\". --// assuming EZReplicator is placed in ReplicatedStorage, --// services local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) --// EZReplicator module local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// create a new subscription \"MAIN\" with initial properties --// this subscription contains the properties Foo and Hotel local MAIN_SUBSCRIPTION = EZReplicator : CreateSubscription ( \"MAIN\" , { Foo = \"Bar\" , Hotel = \"Trivago\" , })","title":"Server sided code"},{"location":"tutorial/subscriptions/#client-sided-code","text":"In the LocalScript, the following code will wait for the Subscription that was made in the server, and print out its properties. --// assuming EZReplicator is placed in ReplicatedStorage, --// services local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) --// EZReplicator module local EZReplicator = require ( ReplicatedStorage : WaitForChild ( \"EZReplicator\" )) --// wait for the \"MAIN\" subscription local MAIN_SUBSCRIPTION = EZReplicator : WaitForSubscription ( \"MAIN\" ) --// read out the properties of the \"MAIN\" subscription local mainSubscriptionProperties = MAIN_SUBSCRIPTION . Properties : GetProperties () for i , v in pairs ( mainSubscriptionProperties ) do print ( tostring ( i ) .. \": \" .. tostring ( v )) end If we were to play test in game with the Script and LocalScript having this code, the output would look something like Foo: Bar Hotel: Trivago","title":"Client sided code"},{"location":"tutorial/subscriptions/#adding-and-removing-subscription-properties","text":"Let's consider a scenario where a Subscription has already been initialized. How do we add properties to the Subscription , and what are the limitations when it comes to adding properties? Adding properties to a Subscription is easy. To add a property to the Subscription , we can use the function Subscription:AddProperty() . In the server script, --// initialize the MAIN subscription local MAIN_SUBSCRIPTION = EZReplicator : CreateSubscription ( \"MAIN\" , { Foo = \"Bar\" , Hotel = \"Trivago\" , }) --// add more properties to the MAIN subscription --// adds the property named \"Goofy\" with the value \"Ahhhh\" MAIN_SUBSCRIPTION : AddProperty ( \"Goofy\" , \"Ahhhh\" ) --// adds the property named \"NinePlusTen\" with the value 21 MAIN_SUBSCRIPTION : AddProperty ( \"NinePlusTen\" , 21 ) The code above adds two properties to the \"MAIN\" Subscrpition . When a new property is added to a Subscription , an event is fired on the Client, but the value is automatically replicated to all clients. Trying to get the values of the new added properties on the client would not throw any errors. To remove properties, we can use the function Subscription:RemoveProperty() . In the server script, --// add more properties to the MAIN subscription --// adds the property named \"Goofy\" with the value \"Ahhhh\" MAIN_SUBSCRIPTION : AddProperty ( \"Goofy\" , \"Ahhhh\" ) --// adds the property named \"NinePlusTen\" with the value 21 MAIN_SUBSCRIPTION : AddProperty ( \"NinePlusTen\" , 21 ) --// what if we want to remove the NinePlusTen property? MAIN_SUBSCRIPTION : RemoveProperty ( \"NinePlusTen\" ) The above code removes the \"NinePlusTen\" property from the Subscription . Once again, this sends a signal to the Client, but also automatically replicates to each client. It is important to note that Subscription:AddProperty() and Subscription:RemoveProperty() are server only functions ! They cannot be used on the client.","title":"Adding and Removing Subscription properties"},{"location":"tutorial/subscriptions/#changing-subscription-properties","text":"Changing Subscription properties is also very easy. The subscription comes with the function Subscription:SetProperty() . Using this function, we can change the values of each property. For example, in the server script, --// initialize the MAIN subscription local MAIN_SUBSCRIPTION = EZReplicator : CreateSubscription ( \"MAIN\" , { Foo = \"Bar\" , Hotel = \"Trivago\" , }) --// change the value of Foo to Cat MAIN_SUBSCRIPTION : SetProperty ( \"Foo\" , \"Cat\" ) The Subscription:SetProperty() function is a server only function ! It cannot be used on the client.","title":"Changing Subscription properties"}]}